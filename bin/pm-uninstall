#!perl

use strict;
use warnings;
use File::Spec;
use Getopt::Long qw/GetOptions/;
use Pod::Usage qw/pod2usage/;
use Config;
use ExtUtils::MakeMaker;

use constant WIN32 => $^O eq 'MSWin32';
my $quote = WIN32 ? q/"/ : q/'/;
my $base_url = 'http://deps.cpantesters.org/depended-on-by.pl?dist=';
my $cpanmetadb = 'http://cpanmetadb.appspot.com/v1.0/package';

our $VERSION = "0.02_01";

my $opt = +{};
GetOptions(
    'v|verbose!'  => \$opt->{verbose},
    'd|dry-run!'  => \$opt->{dry_run},
    'dependence!' => \$opt->{dependence},
    'h|help!'     => \$opt->{help},
);
my @modules = map { my $org = $_; s|::|/|g; [$org, $_] } @ARGV;
pod2usage 1 if $opt->{help} or scalar @modules <= 0;

main();
exit;

sub main {
    init_tools();

    print "--- dry-run ---\n" if !$opt->{dependence} and $opt->{dry_run};
    for my $module (@modules) {
        my $module_name = $module->[0];
        my $module_path = $module->[1];

        print "Uninstalling $module_name\n" unless $opt->{dependence};

        my $is_installed;
        for my $lib (@INC) {
            my $packlist = File::Spec->catfile("$lib/auto/$module_path/.packlist"); 
            if (-f $packlist) {
                open my $fh, '<', $packlist or die "$packlist: $!";
                while (<$fh>) {
                    chomp;
                    if ($opt->{dependence}) {
                        (my $file = $_) =~ s|\\|/|g;
                        if (-f $_ and $file =~ m|$module_path\.pm$|) {
                            my $yaml = get("$cpanmetadb/$module_name"); 
                            eval "use Parse::CPAN::Meta; 1" or die "Cannot required Parse::CPAN::Meta.\n";
                            my $meta = parse_meta_string($yaml);
                            die "Couldn't finding $module on cpanmetadb failed.\n" unless $meta->{distfile};
                            (my $dist_name = $meta->{distfile}) =~ s{\w+/\w+/\w+/([\w.-]+)-[\w.]+\.(?:tar\.(?:gz|bz|bz2)|zip)}{$1};

                            my $version = MM->parse_version($_);
                            my $dist .= "$dist_name-$version";
                            my $content = get("$base_url$dist");
                            warn "Couldn't get dependence modules from $dist\n" and last unless $content;
                            print "$dist is depended on by\n";
                            for my $depended_module ($content =~ m|<th align=left>([^<]+)</th>|smg) {
                                print "    $depended_module\n";
                            }
                            last;
                        }
                    }
                    else {
                        print -f $_ ? 'unlink   ' : 'not found', " : $_\n" if $opt->{verbose};
                        unlink $_ or warn "$_: $!\n" unless $opt->{dry_run};
                    }
                }
                close $fh;
                unlink $packlist or warn "$packlist: $!\n" unless $opt->{dry_run} or $opt->{dependence};
                $is_installed = 1;
                last;
            }
        }
        warn "$module_name not installed or .packlist not found\n" unless $is_installed;
        print "Successfully $module_name\n" if !$opt->{dependence} and $is_installed;
    }
}

# taken from cpan-outdated
sub which {
    my($name) = @_;
    my $exe_ext = $Config{_exe};
    foreach my $dir(File::Spec->path){
        my $fullpath = File::Spec->catfile($dir, $name);
        if (-x $fullpath || -x ($fullpath .= $exe_ext)){
            if ($fullpath =~ /\s/ && $fullpath !~ /^$quote/) {
                $fullpath = "$quote$fullpath$quote"
            }
            return $fullpath;
        }
    }
    return;
}

sub init_tools {
    if (!$ENV{DEBUG_WGET} && eval { require LWP::Simple }) {
        *get = sub { LWP::Simple::get(@_) };
    }
    elsif (my $wget = which('wget')) {
        *get = sub {
            my($uri) = @_;
            open my $fh, "$wget $uri -q -O - |" or die "wget $uri: $!";
            local $/;
            <$fh>;
        };
    }
    else {
        die "Cannot find LWP::Simple and wget.\n";
    }
}

sub parse_meta_string {
    my $yaml = shift;
    return eval { (Parse::CPAN::Meta::Load($yaml))[0] } || {};
}

__END__

=head1 NAME

  pm-uninstall - Uninstall modules

=head1 SYNOPSIS

  pm-uninstall [options] Module ...

  options:
      -v,--verbose    Truns on chatty output
      -d,--dry-run    Rehearsal
      -h,--help       This help message
      
      --dependence    Show the module dependency.

